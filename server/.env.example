# ============================================================================
# CodeRunner Server - Environment Configuration
# ============================================================================
# Copy this file to .env and adjust values as needed for your deployment

# === Server Configuration ===
NODE_ENV=development
PORT=3000
HOST=0.0.0.0
LOG_LEVEL=info
LOG_FORMAT=text

# Admin Dashboard Authentication Key
# IMPORTANT: Change this in production!
# Authenticate via X-Admin-Key header (never send keys in URLs).
ADMIN_KEY=your-secure-admin-key-here

# === CORS Origins ===
# Comma-separated list of allowed origins for CORS and WebSocket connections.
# Default: http://localhost:5173,http://localhost:3000
# CORS_ORIGINS=http://localhost:5173,http://localhost:3000

# === Rate Limiting ===
# Max /api/run requests per minute per IP (default: 30)
# RATE_LIMIT_API_RUN=30
# Max WebSocket 'run' events per 10 seconds per socket (default: 10)
# RATE_LIMIT_SOCKET_RUN=10

# === Docker Resource Configuration ===
# Memory ceiling per container — this is NOT pre-allocated, only a cap.
# A Python/JS/C++ container typically uses 15-40MB actual RAM.
# Lower ceiling = more containers can run before OOM, tighter safety net.
DOCKER_MEMORY=96m
DOCKER_CPUS=0.25

# SQL/Notebook containers need more headroom (Postgres, Jupyter kernels)
DOCKER_MEMORY_SQL=384m
DOCKER_CPUS_NOTEBOOK=1

# Docker command timeout (milliseconds)
DOCKER_CMD_TIMEOUT=15000

# Process execution timeout (used in code execution)
DOCKER_TIMEOUT=30s

# === Network Configuration ===
# Session network prefix for Docker networks
NETWORK_PREFIX=coderunner-session-

# Docker subnet pools — CHANGE THESE if 10.201/10.202 overlap with any machine on your LAN.
# Use any two 10.x.0.0/16 ranges that no physical or virtual machine on your network uses.
# Example for a lab already using 10.201.x.x: set DOCKER_SUBNET_POOL1=10.210
#DOCKER_SUBNET_POOL1=10.201
#DOCKER_SUBNET_POOL2=10.202

# === Session Container Management ===
# Container TTL before automatic cleanup (milliseconds)
SESSION_TTL=60000

# Cleanup check interval (milliseconds)
CLEANUP_INTERVAL=30000

# Orphaned network age threshold (milliseconds)
ORPHANED_NETWORK_AGE=300000

# Maximum containers per session (warning threshold)
MAX_CONTAINERS_PER_SESSION=10

# Enable/disable automatic cleanup
AUTO_CLEANUP=true

# Pre-warm container pool (experimental)
PREWARM_POOL=false

# Maximum concurrent execution requests
# Controls how many 'run' requests execute in parallel
# Higher values use more resources but execute faster
# Recommended: 5-10 for typical hardware, adjust based on available CPU/RAM
MAX_CONCURRENT_SESSIONS=5

# === Runtime Images ===
# Docker image names for each supported language
PYTHON_RUNTIME_IMAGE=python-runtime
CPP_RUNTIME_IMAGE=cpp-runtime
JAVASCRIPT_RUNTIME_IMAGE=javascript-runtime
JAVA_RUNTIME_IMAGE=java-runtime
POSTGRES_RUNTIME_IMAGE=postgres-runtime

# === File Management ===
TEMP_DIR=/tmp
MAX_FILE_SIZE=10485760
MAX_FILES_PER_SESSION=50

# === Logging ===
REQUEST_LOGGING=true

# ============================================================================
# Docker Daemon Configuration
# ============================================================================
# /etc/docker/daemon.json must declare the same subnet ranges you chose above
# so Docker's IPAM doesn't hand those blocks to unrelated containers first.
#
# Default (matches DOCKER_SUBNET_POOL1=10.201, DOCKER_SUBNET_POOL2=10.202):
#
# {
#   "default-address-pools": [
#     { "base": "10.201.0.0/16", "size": 28 },
#     { "base": "10.202.0.0/16", "size": 28 }
#   ]
# }
#
# If you change DOCKER_SUBNET_POOL1/POOL2, update the bases here to match
# and then: sudo systemctl restart docker
#
# Each pool provides 4096 x /28 subnets = 4096 concurrent isolated sessions.
# ============================================================================
